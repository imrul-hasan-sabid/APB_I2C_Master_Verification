
// This file was autogenerated by PeakRDL-uvm
package APB_I2C_master_ral_model;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    
    // Reg - APB_I2C_master_reg_map::TWCR
    class APB_I2C_master_reg_map__TWCR extends uvm_reg;
        rand uvm_reg_field TWIE;
        rand uvm_reg_field TWEN;
        rand uvm_reg_field TWWC;
        rand uvm_reg_field TWSTO;
        rand uvm_reg_field TWSTA;
        rand uvm_reg_field TWEA;
        rand uvm_reg_field TWINT;

        /*function new (string name="",     // Register name 
                      int unsigned n_bits,// Register width in bits
                      int has_coverage);  // Coverage model supported by theregister*/
                      
        function new(string name = "APB_I2C_master_reg_map__TWCR");
            super.new(name, 32, UVM_NO_COVERAGE);
        endfunction : new
        
        /* configure( uvm_reg parent,                 // The containing register
                      int unsigned size,              // How many bits wide 
                      int unsigned lsb_pos ,          // Bit offset within the register
                      string    access ,              // "RW", "RO", "WO" etc
                      bit     volatile ,              // Volatile if bit is updated by hardware
                      uvm_reg_data_t reset,           // The reset value
                      bit has_reset,                  // Whether the bit is reset
                      bit is_rand,                    // Whether the bit can be randomized
                      bit individually accessible );  //i.e. Totally contained within a byte lane */

        virtual function void build();
            this.TWIE = new("TWIE");
            this.TWIE.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.TWEN = new("TWEN");
            this.TWEN.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.TWWC = new("TWWC");
            this.TWWC.configure(this, 1, 3, "RO", 1, 'h0, 1, 1, 0);
            this.TWSTO = new("TWSTO");
            this.TWSTO.configure(this, 1, 4, "RW", 1, 'h0, 1, 1, 0);
            this.TWSTA = new("TWSTA");
            this.TWSTA.configure(this, 1, 5, "RW", 0, 'h0, 1, 1, 0);
            this.TWEA = new("TWEA");
            this.TWEA.configure(this, 1, 6, "RW", 0, 'h0, 1, 1, 0);
            this.TWINT = new("TWINT");
            this.TWINT.configure(this, 1, 7, "RW", 1, 'h0, 1, 1, 0);
        endfunction : build
    endclass : APB_I2C_master_reg_map__TWCR

    // Reg - APB_I2C_master_reg_map::TWDR
    class APB_I2C_master_reg_map__TWDR extends uvm_reg;
        rand uvm_reg_field TWDR_;

        function new(string name = "APB_I2C_master_reg_map__TWDR");
            super.new(name, 32, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.TWDR_ = new("TWDR_");
            this.TWDR_.configure(this, 8, 0, "RW", 0, 'hff, 1, 1, 0);
        endfunction : build
    endclass : APB_I2C_master_reg_map__TWDR

    // Reg - APB_I2C_master_reg_map::TWSR
    class APB_I2C_master_reg_map__TWSR extends uvm_reg;
        rand uvm_reg_field TWS;
        rand uvm_reg_field TWPS;

        function new(string name = "APB_I2C_master_reg_map__TWSR");
            super.new(name, 32, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.TWS = new("TWS");
            this.TWS.configure(this, 2, 0, "RW", 0, 'h0, 1, 1, 0);
            this.TWPS = new("TWPS");
            this.TWPS.configure(this, 5, 3, "RO", 1, 'h1f, 1, 1, 0);
        endfunction : build
    endclass : APB_I2C_master_reg_map__TWSR

    // Reg - APB_I2C_master_reg_map::TWAR
    class APB_I2C_master_reg_map__TWAR extends uvm_reg;
        rand uvm_reg_field TWGCE;
        rand uvm_reg_field TWA;

        function new(string name = "APB_I2C_master_reg_map__TWAR");
            super.new(name, 32, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.TWGCE = new("TWGCE");
            this.TWGCE.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.TWA = new("TWA");
            this.TWA.configure(this, 7, 1, "RW", 0, 'h7f, 1, 1, 0);
        endfunction : build
    endclass : APB_I2C_master_reg_map__TWAR

    // Reg - APB_I2C_master_reg_map::TWBR
    class APB_I2C_master_reg_map__TWBR extends uvm_reg;
        rand uvm_reg_field TWBR_;

        function new(string name = "APB_I2C_master_reg_map__TWBR");
            super.new(name, 32, UVM_NO_COVERAGE);
        endfunction : new

        virtual function void build();
            this.TWBR_ = new("TWBR_");
            this.TWBR_.configure(this, 8, 0, "RW", 0, 'h0, 1, 1, 0);
        endfunction : build
    endclass : APB_I2C_master_reg_map__TWBR

    // Addrmap - APB_I2C_master_reg_map
    class APB_I2C_master_reg_map extends uvm_reg_block;
        rand APB_I2C_master_reg_map__TWCR TWCR;
        rand APB_I2C_master_reg_map__TWDR TWDR;
        rand APB_I2C_master_reg_map__TWSR TWSR;
        rand APB_I2C_master_reg_map__TWAR TWAR;
        rand APB_I2C_master_reg_map__TWBR TWBR;

        function new(string name = "APB_I2C_master_reg_map");
            super.new(name);
        endfunction : new

        virtual function void build();
            /*function uvm_reg_map create_map(string name, // Name of the map handle
                                            uvm_reg_addr_t base_addr,// The Map's base address
                                            int unsigned n_bytes,    // Map access width in bytes
                                            uvm_endianness_e endian, // The endianess of the map
                                            bit byte_addressing=1);  // Whether byte addressing is supported   */   

            this.default_map = create_map("reg_map", 0, 4, UVM_LITTLE_ENDIAN);

            this.TWCR = new("TWCR");
            this.TWDR = new("TWDR");
            this.TWSR = new("TWSR");
            this.TWAR = new("TWAR");
            this.TWBR = new("TWBR");
            
            /* configure (uvm_reg_block blk_parent,           // The containing reg block
                          uvm_reg_file regfile_parent = null, // Optional, not used
                          string hdl_path = "");              // Used if HW register can be specified in one hdl path string */            
            this.TWCR.configure(this);
            this.TWDR.configure(this);
            this.TWSR.configure(this);
            this.TWAR.configure(this);
            this.TWBR.configure(this);

            this.TWCR.build();
            this.TWDR.build();
            this.TWSR.build();
            this.TWAR.build();
            this.TWBR.build();

            /*//The map provides information on the offset of the registers, memoriesand/or register blocks contained within it. uvm_map add_reg method prototype:
            add_reg (uvm_reg rg,                       // Register object handle
                     uvm_reg_addr_t offset,            // Register address offset
                     string rights = "RW",             // register access policy
                     unmapped=0,                       // If true, register does not appear in the address map  and a frontdoor access needs to be defined
                     uvm_reg_frontdoor frontdoor=null);// Handle to register frontdoor access object */             
            this.default_map.add_reg(this.TWCR, 'h0);
            this.default_map.add_reg(this.TWDR, 'h4);
            this.default_map.add_reg(this.TWSR, 'h8);
            this.default_map.add_reg(this.TWAR, 'hc);
            this.default_map.add_reg(this.TWBR, 'h10);            

            lock_model();
        endfunction : build
    endclass : APB_I2C_master_reg_map

endpackage: APB_I2C_master_ral_model

